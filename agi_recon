#! /usr/local/radish-link/perl
# Simplish perl script to run matlab agilent recon
#
# # comment
# name=value
#
#
#


use strict;
use warnings;
my $ERROR_EXIT = 1;
my $GOOD_EXIT  = 0;
use Env qw(RADISH_RECON_DIR);
if (! defined($RADISH_RECON_DIR)) {
    print STDERR "Environment variable RADISH_RECON_DIR must be set. Are you user omega?\n";
    print STDERR "   CIVM HINT setenv RADISH_RECON_DIR /recon_home/script/dir_radish\n";
    print STDERR "Bye.\n";
    exit $ERROR_EXIT;
}
#use lib "$RADISH_RECON_DIR/modules/script";
use Env qw(RADISH_PERL_LIB);
if (! defined($RADISH_PERL_LIB)) {
    print STDERR "Cannot find good perl directories, quiting\n";
    exit $ERROR_EXIT;
}
use lib split(':',$RADISH_PERL_LIB);
use Env qw(RECON_HOSTNAME);
if (! defined($RECON_HOSTNAME)) {
    print STDERR "Environment variable RECON_HOSTNAME must be set.";
    exit $ERROR_EXIT;
}

require Headfile;
#require shared;
require pipeline_utilities;
use English;
use Getopt::Std;
#use civm_simple_util qw(load_file_to_array);
my $debug_val=0;
my $VERSION = "20121126_james";

    my %options = ();
if (! getopts('x:y:xz:f:r:w:b:p:c:t:h:m:', \%options)) {
    error_out('Unreconized options passed to agi_recon');
}

my $function_m_name='agilent_recon';
#my $pfile_path=shift(@ARGV);
#my ($n,$work_dir,$ext)=fileparts($pfile_path);
my $work_dir=$ARGV[6]; #7th argument
my $pfile_name=$ARGV[7]; #8th argument
my $args="\'$work_dir\',\'$pfile_name\',1"; # the one says we're running command line to agilent_recon.m
#my $work_dir='/tmp/';
open_log($work_dir);

my $engine_file = join("_","engine","$RECON_HOSTNAME","radish_dependencies");
my $the_engine_constants_path = join("/",$RADISH_RECON_DIR, $engine_file);
my $Engine_constants = new Headfile ('ro', $the_engine_constants_path);
$Engine_constants->check()         or exit("Unable to open engine constants file $the_engine_constants_path\n");
$Engine_constants->read_headfile() or exit("Unable to read engine constants from file $the_engine_constants_path\n");

#my $work_dir=$Engine_constants->get_value('engine_work_directory');
my $short_unique_purpose='agi_recon'.$PID; #$Engine_constants->get_value('scanner_pfile_header_app')
my $matlab_app=$Engine_constants->get_value('engine_app_matlab');

#$Engine_constants->get_value('engine_work_directory');

#passing empty string to nohf at end of args so destination will be cmdline
my $mat_cmd=make_matlab_command_nohf($function_m_name, $args, $short_unique_purpose, $work_dir, $matlab_app,''); 
# calls make_matlab_m_file();
#   my ($function_m_name, $args, $short_unique_purpose, $work_dir, $matlab_app) = @_;
my $rc=execute(1,"",$mat_cmd);
#my $procpar_hf=$work_dir.'procpar'.'.headfile';
#exec("cat $procpar_hf");
# my @lines;
# load_file_to_array($procpar_hf,@lines);
# for my $line (@lines) {
#     print("$line\n");
# }
#exit;

